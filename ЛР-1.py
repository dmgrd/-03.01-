import random

# Константы
PLAYER_SYMBOLS = ".OX"  # Символы игроков: '.' - пустая ячейка, 'O' и 'X' - крестики и нолики
ROW_INDICES = "ABC"  # Индексы строк для ввода пользователем
COLUMN_INDICES = "123"  # Индексы колонок для ввода пользователем

# Функция для вывода игрового поля на экран
def print_game_map(gm):
    for row in gm:  # Проходим по каждой строке игрового поля
        for cell in row:  # Проходим по каждой ячейке в строке
            print(PLAYER_SYMBOLS[cell], end=" ")  # Выводим символ, соответствующий значению в ячейке (0 - '.', 1 - 'O', 2 - 'X')
        print()  # Переход на новую строку после каждой строки игрового поля

# Функция для проверки ничьей, если все ячейки заполнены)
def is_tie(gm):
    for row in gm:  # Проходим по каждой строке игрового поля
        for cell in row:  # Проверяем каждую ячейку
            if cell == 0:  # Если есть хотя бы одна пустая ячейка, значит, игра продолжается
                return False
    return True  # Если все ячейки заняты, это ничья

# Функция для проверки завершения игры
def is_completed(gm):
    # Проверка игрового поля
    assert len(gm) > 0, "Поле должно иметь хотя бы одну строку"
    assert len(gm[0]) > 0, "Поле должно иметь хотя бы одну колонку"

    # Проверка победы по строкам
    for row in gm:
        first = row[0]  # Берем первый элемент строки
        if first != 0:  # Если ячейка непустая
            for cell in row[1:]:  # Проверяем остальные ячейки в строке
                if cell != first:  # Если хотя бы одна ячейка не совпадает, прекращаем проверку
                    break
            else:
                return True, first  # Если все ячейки одинаковы, возвращаем победителя

    # Проверка победы по столбцам
    for j in range(len(gm[0])):  # Проходим по каждому столбцу
        first = gm[0][j]  # Берем первый элемент столбца
        if first != 0:  # Если ячейка непустая
            for i in range(1, len(gm)):  # Проверяем остальные элементы столбца
                if gm[i][j] != first:  # Если хотя бы одна ячейка не совпадает, прекращаем проверку
                    break
            else:
                return True, first  # Если все ячейки одинаковы, возвращаем победителя

    # Проверка победы по главной диагонали
    assert len(gm) == len(gm[0]), "TODO: Пока работает только на квадратных полях"  # Убедимся, что поле квадратное
    diag = gm[0][0]  # Берем элемент из верхнего левого угла
    if diag != 0:  # Если ячейка непустая
        for i in range(len(gm)):  # Проверяем остальные элементы диагонали
            if gm[i][i] != diag:  # Если хотя бы один элемент не совпадает, прекращаем проверку
                break
        else:
            return True, diag  # Если все ячейки одинаковы, возвращаем победителя

    # Проверка победы по побочной диагонали
    inv_diag = gm[0][len(gm) - 1]  # Берем элемент из верхнего правого угла
    if inv_diag != 0:  # Если ячейка непустая
        for i in range(len(gm)):  # Проверяем остальные элементы побочной диагонали
            if gm[i][len(gm) - i - 1] != inv_diag:  # Если хотя бы один элемент не совпадает, прекращаем проверку
                break
        else:
            return True, inv_diag  # Если все ячейки одинаковы, возвращаем победителя

    # Если победителя нет, проверяем на ничью
    return is_tie(gm), 0  # Возвращаем результат ничьей

# Функция случайного выбора хода компьютера
def random_player(gm, player):
    row_index = list(range(len(gm)))  # Получаем список индексов строк игрового поля
    random.shuffle(row_index)  # Перемешиваем индексы строк в случайном порядке
    for i in row_index:  # Проходим по перемешанным строкам
        row = gm[i]  # Выбираем строку
        empty_cells = []  # Список для хранения индексов пустых ячеек
        for j, cell in enumerate(row):  # Проходим по ячейкам строки
            if cell == 0:  # Если ячейка пустая
                empty_cells.append(j)  # Добавляем индекс ячейки в список пустых

        if len(empty_cells) > 0:  # Если есть пустые ячейки
            player_row = i  # Запоминаем индекс строки
            player_column = random.choice(empty_cells)  # Выбираем случайную пустую ячейку в строке
            return player_row, player_column  # Возвращаем координаты выбранной ячейки

# Функция ввода хода игрока
def input_player(gm, player):
    while True:
        print_game_map(gm)  # Выводим текущее состояние игрового поля

        player_input = input(f"Игрок №{player}({PLAYER_SYMBOLS[player]}), введите позицию: ")  # Запрашиваем у игрока ввод позиции
        if len(player_input) != 2:  # Проверяем, что введены ровно два символа
            print("Введено неверное количество символов. Формат: A1.")
            continue
        player_row, player_column = player_input  # Разделяем ввод на строку и колонку

        player_row = ROW_INDICES.find(player_row)  # Преобразуем введенную букву в индекс строки
        if player_row == -1:  # Если введена неверная буква
            print("Введен неверный номер ряда. Укажите букву:", ','.join(ROW_INDICES))
            continue

        player_column = COLUMN_INDICES.find(player_column)  # Преобразуем введенную цифру в индекс колонки
        if player_column == -1:  # Если введена неверная цифра
            print("Введен неверный номер колонки. Укажите цифру:", ','.join(COLUMN_INDICES))
            continue

        if gm[player_row][player_column] > 0:  # Если выбранная ячейка уже занята
            print("Эта ячейка уже занята, выберите другую.")
            continue

        return player_row, player_column  # Возвращаем индекс строки и колонки

# Создание пустого игрового поля 3x3
game_map = []
for _ in range(3):  # Проходим по каждой строке
    temp = []  # Временный список для строки
    for _ in range(3):  # Добавляем в строку три пустые ячейки
        temp.append(0)
    game_map.append(temp)  # Добавляем строку на игровое поле

# Определяем, кто будет начинать игру
current_player = 1  # Игрок 1 начинает игру
completed, who_won = False, 0  # Создание переменных состояния игры

# Список функций игроков: игрок с вводом с клавиатуры и случайный компьютерный игрок
game_players = [None, input_player, random_player]

# Основной игровой цикл
while not completed:  # Пока игра не завершена
    player_function = game_players[current_player]  # Выбираем функцию для текущего игрока
    row_index, column_index = player_function(game_map, current_player)  # Получаем ход от игрока
    game_map[row_index][column_index] = current_player  # Обновляем игровое поле с учетом хода игрока

    completed, who_won = is_completed(game_map)  # Проверяем, завершена ли игра и кто победил

    if current_player == 1:  # Меняем игрока
        current_player = 2
    elif current_player == 2:
        current_player = 1
    else:
        print("Неверный номер игрока")  # Защита от ошибок с некорректным номером игрока
        exit(1)

# Выводим итоговое игровое поле и результат игры
print_game_map(game_map)
if who_won != 0:  # Если кто-то победил
    print(f"Игрок №{who_won} победил!")
else:
    print("Игра завершилась на ничье.")  # Если победителя нет, выводим сообщение о ничье